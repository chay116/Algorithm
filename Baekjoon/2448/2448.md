# <span style="font-size:17pt; font-weight:bold">[BOJ 1377. 버블 소트](https://www.acmicpc.net/problem/1377)</span>
랭크 : <span style="color:gold">__골드3__</span>
<br>

# <span style="font-size:15pt;color:BurlyWood">문제 풀이</span>

처음하는 방법은

1. 앞에서 부터 순서대로 BST에 입력을 해준다. 이떄 각 노드에 대해서 계산을 해줘야하는데, 들어갈 당시 자기보다 큰 node가 들어있는 수를 계산한다.
2. 자기 자신보다 큰 node의 수가 앞으로 움직여야하는 수에 해당한다. 따라서, 노드를 넣을 떄마다 이 값의 최대값을 갱신해준다.
3. 이 값을 최대로 만드는 노드는, 자신의 뒤에 나보다 작은 노드가 존재하지 않는 경우다.

과 같았지만, 힘들게 겨우 구현했더니 시간초과가 떴다. 최악의 경우 $O(N^2)$ 였기 떄문에 어느 정도 예상은 했지만 조금 아쉽다. 아마 RB tree를 썼으면 가능하지 않았을까 싶기는 하다..
다르게 푸는 방법은 처음 위치와 입력 값을 pair로 저장하고 stable_sort로 정렬하고 난 뒤, 이전 위치 - 현재 위치 값이 가장 큰 수를 고르면 된다. 왜냐하면 큰 수를 제외하고 작은 수의 경우는 한번 시행할 때 마다 앞으로 가는데, 결국 가장 큰 수에 대해서는 시행 회수와 직결되기 때문이다.
<br>

|`알고리즘`|`시간복잡도`|`공간복잡도`|
|:---:|:---:|:---:|
| divide&conquer | $O(N \log N)$| $O(N)$ |

<br><br>
