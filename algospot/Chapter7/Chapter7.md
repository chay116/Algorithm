# Chapter 6 divide&conquer(분할 정복)

## <span style="color:#959597">__1. 도입__<span>
주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 계산해 냅니다. 이 방법이 재귀 호출과 가장 다른 점은 문제를 한조각과 나머지 전체로 나누는 대신, 분할 정복은 보통 동일한 크기의 문제로 n 분할 한다는 점입니다. 이는 보통 세가지 순서로 이루어지는데
1. Divide : 문제를 더 작은 문제로 분할하는 과정
2. Merge : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
3. Base Case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제


따라서 문제를 잘 나누고, 적당한 선에서 계산을 수행하여, 이를 잘 조합해야합니다. 재귀 분할의 가장 큰 장점은 시간 복잡도인데, 일반적인 재귀의 경우는 $O(n)$인 반면에 재귀 분할의 경우는 $O(\log n)$입니다.
<hr/>

### - <span style="color:green">_quadtree_ (난이도 : 하)<span>

[문제 링크](https://algospot.com/judge/problem/read/QUADTREE) <br/>
완전 탐색을 이용하여, 인접한 칸을 하나씩 시도해보는 방법으로 풀어나간다. 이떄 base case인 경우의 조건을 잘 맞춰주는 것이 중요하다. 또한 재귀함수 문제들을 부분 문제로 잘 이끌어가느냐가 중요한 요소로서 작용합니다. 사실 이번 챕터에서 원하는 정답은 brute force로만 해결하는 거겠지만 사이트 올라온 시간 제한으로는 불가능하다. 따라서 8장의 dp를 활용하게 되는데, 5x5 board위에서 해당 알파벳이 n번째 위치의 글자로서 쓸모가 있는지를 memorization하는 기법을 통해 풀어낼 수 있다.<br/>

### - <span style="color:orange">_fence_ (난이도 :중)<span>

[문제 링크](https://algospot.com/judge/problem/read/FENCE) <br/>
가능한 조합의 수를 계산하는 문제는 모든 조합을 만들어보되, 이들의 경우의 수가 겹치지 않도록 하는 것이 중요합니다. 또한 답의 수를 예측할 수 있으므로, 시간적 비용을 예측하는 것도 중요합니다. 문제를 풀 때, 중복되지 않도록 조건을 잘 걸어주어야 합니다. 또한, 탐색을 할 때에는 DFS를 활용하여 넣고 빼는 알고리즘을 구현하였습니다.<br/>

### - <span style="color:red">_FANMEETING_ (난이도 : 상)<span>

[문제 링크](https://algospot.com/judge/problem/read/FANMEETING) <br/>
이 문제도 모든 경우의 수를 생성하는 완전 탐색을 이용해 해결할 수 있습니다. 이 때도 위의 picnic과 같이 중복된 수를 세지 않도록 하는 것이 중요한데, 새로운 sub problem을 정의를 할 때, 주어진 문제에서 좀 더 조건을 부여하는 것으로 완전 탐색을 해결할 수 있습니다. 이번의 경우는 블록을 넣는 순서와, 들어갈 수 있는 블록을 잘 정의하는 것으로 가능합니다. 또한, 탐색을 할 때에는 DFS를 활용하여 넣고 빼는 알고리즘을 구현하였습니다.
